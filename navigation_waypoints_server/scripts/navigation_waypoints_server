#!/usr/bin/env python

import roslib; roslib.load_manifest('navigation_waypoints_server')

import rospy
import actionlib

from threading import Lock

import navigation_waypoints_server.msg
import navigation_waypoints_server.srv
import nav_msgs.msg
import nav_msgs.srv
import move_base_msgs.msg as move_base_msgs
import geometry_msgs.msg as geometry_msgs

class PreemptRequested(Exception):
    pass

class WaypointFailed(Exception):
    pass

class NavWaypointsServer(object):
    def __init__(self, action_name):
        # list of pending waypoints. Required to be a member variable
        # because we need to be able to change it while executing the path
        # without preempting the action.
        self.pending = []
        self.lock = Lock()

        self.params = self.parse_params()
        
        if self.params['global_planner_service']:
            try:
                rospy.wait_for_service(self.params['global_planner_service'], 2)
            except rospy.ROSException, e:
                rospy.logerr('Unable to find service `%s`. Ignoring' % self.params['global_planner_service'])
            self.make_plan = rospy.ServiceProxy(self.params['global_planner_service'], nav_msgs.srv.GetPlan)
        else:
            self.make_plan = None
        self.execute_path = actionlib.SimpleActionServer(action_name, navigation_waypoints_server.msg.ExecutePathAction,
                                                         self.execute_action)
        self.move_base = actionlib.SimpleActionClient(
            self.params['move_base_action'], move_base_msgs.MoveBaseAction)
        if self.params['fallback_move_base_action']:
            self.fallback_move_base = actionlib.SimpleActionClient(
                self.params['fallback_move_base_action'], move_base_msgs.MoveBaseAction)
        else:
            self.fallback_move_base = None

        self.update_waypoints_service = rospy.Service(
            "~update_waypoints", navigation_waypoints_server.srv.UpdateWaypoints, self.update_waypoints)
        
    def parse_params(self):
        """
        Currently, we support the following parameters:

        - base_frame: the name of the robot's base_link

        - map_frame: the name of the fixed frame, i.e. map

        - move_base_action: name of the primary move_base action
            
        - fallback_move_base_action: name of the fallback navigation action
          which is used if no valid plan can be found for driving to a
          waypoint
            
        - global_planner_service: service to be called in order to find out if
          we need to use the fallback nav action. If empty, the fallback is
          only called when the primary nav action fails.
              
        This function returns a dictionary of parameters
        """
        return {
            'base_frame': rospy.get_param('~base_frame', 'base_link'),
            'map_frame':  rospy.get_param('~map_frame', '/map'),
            'move_base_action': rospy.get_param('~move_base_action', '/move_base'),
            'fallback_move_base_action': rospy.get_param('~fallback_move_base_action', None),
            'global_planner_service': rospy.get_param('~global_planner_service', None)}
    
    def check_waypoint_plan(self, goal):
        """
        Checks if there is a plan from start to goal. If the parameter
        'global_planner_service' is not set, we cannot check and therefore
        return True.
        """
        if self.make_plan:
            try:
                # Start is the robot's current location, i.e. an
                # identity pose in the base frame
                plan = self.make_plan(start=geometry_msgs.PoseStamped(), goal=goal,
                                      tolerance=0.0)
                if len(plan.plan.poses) > 0:
                    print 'yep'
                else:
                    print 'nope', plan
                return len(plan.plan.poses) > 0
            except rospy.ServiceException, e:
                print 'nope, err'
                return False
        else:
            return True

    def call_move_base(self, action, goal, poll_timeout=0.1):
        """
        Executes the (move_base-)action and checks for cancellation of
        our own server. In that case, raises an exception. If the goal
        cannot be reached, returns False, otherwise True.
        """
        goal_msg = move_base_msgs.MoveBaseGoal(target_pose=goal)
        action.send_goal(goal_msg)

        while not action.wait_for_result(rospy.Duration(poll_timeout)):
            if self.execute_path.is_preempt_requested():
                action.cancel_goal()
                raise PreemptRequested()
        action.get_result()
        if action.get_state == actionlib.GoalStatus.SUCCEEDED:
            return True
        else:
            return False
        
    def execute_action(self, goal):
        visited = []
        invalid = []
        with self.lock:
            self.pending = goal.waypoints

        try:
            while(len(self.pending) > 0):
                try:
                    with self.lock:
                        current = self.pending[0]
                        self.pending = self.pending[1:]

                    self.execute_path.publish_feedback(
                        navigation_waypoints_server.msg.ExecutePathFeedback(
                            current = current,
                            visited = visited,
                            invalid = invalid,
                            pending = self.pending))

                    if self.check_waypoint_plan(current):
                        if not self.call_move_base(self.move_base, current):
                            if not self.fallback_move_base:
                                raise WaypointFailed()
                            elif not self.call_move_base(self.fallback_move_base, current):
                                raise WaypointFailed()                                
                    elif not self.call_move_base(self.fallback_move_base, current):
                        raise WaypointFailed()
                    visited += [current]
                    
                except WaypointFailed, e:
                    invalid += [current]
                    if not goal.continue_on_error:
                        raise e
            self.execute_path.set_succeeded(
                navigation_waypoints_server.msg.ExecutePathResult(
                    visited = visited,
                    invalid = invalid,
                    pending = self.pending))                

        except PreemptRequested, e:
            self.execute_path.set_preempted(
                navigation_waypoints_server.msg.ExecutePathResult(
                    visited = visited,
                    invalid = invalid,
                    pending = [current] + self.pending))
        except WaypointFailed, e:
            self.execute_path.set_aborted(
                navigation_waypoints_server.msg.ExecutePathResult(
                    visited = visited,
                    invalid = invalid,
                    pending = self.pending))

    def update_waypoints(self, request):
        with self.lock:
            self.pending = request.waypoints
            return []

if __name__ == '__main__':
    rospy.init_node('navigation_waypoints_server')
    waypoints_server = NavWaypointsServer('~execute_path')
    rospy.spin()
